import math

import astropy
import numpy as np
from astropy.coordinates import SkyCoord, Angle
import astropy.units as u
from astropy.time import Time
from numpy import ndarray

from jasmine_toolkit.utils.parameters import Parameters


class PointingPlan:
    def __init__(self):
        self.__grid = None
        self.__pointing: SkyCoord = None
        self.__gap_on_the_sky = 0
        self._generate_grid()

    def add_entry(self, entry: np.ndarray) -> np.ndarray:
        pass

    def get_array(self) -> np.ndarray:
        # TODO This code is dangerous. copy function of numpy.ndarray
        #  automatically select deep or shallow copy, and is not controllable
        #  by user.  Return value should be a new object generated by deep
        #  copy. Some instruction show that use copy.deepcopy(ndarray) but
        #  error occurs.  Need to find appropriate method.
        return self.__grid

    def _generate_grid(self):
        """

        Returns: empty 3 dimensional list. The first and the second index
         denotes the location on the grid, and the components of the third
         index are [Time, number of observation].

        """
        p = Parameters.get_instance()
        detector_gap = p.detector_separation_x \
                       - p.detector_format_x * p.pixel_size
        self.__gap_on_the_sky = detector_gap / p.effective_focal_length
        l_min = p.minimum_l
        l_max = p.maximum_l
        b_min = p.minimum_b
        b_max = p.maximum_b
        n_l = int((l_max - l_min) / self.__gap_on_the_sky) + 1
        n_b = int((b_max - b_min) / self.__gap_on_the_sky) + 1
        self.__grid = [[[] for i in range(n_b)] for j in range(n_l)]

    def find_next_pointing(self) -> SkyCoord:
        l0 = -1
        b0 = -1
        min_count = 100000
        n_l = len(self.__grid)
        n_b = len(self.__grid[0])
        for ll in range(n_l):
            for b in range(n_b):
                if len(self.__grid[ll][b]) < min_count:
                    min_count = len(self.__grid[ll][b])
                    l0 = ll
                    b0 = b
        p = Parameters.get_instance()
        coord_l = p.minimum_l + l0 * self.__gap_on_the_sky
        coord_b = p.minimum_b + b0 * self.__gap_on_the_sky
        self.__pointing = SkyCoord(l=coord_l * u.rad, b=coord_b * u.rad,
                                   frame='galactic')
        return self.__pointing

    def make_observation(self, t: Time, pa: Angle, num_exposure: int):
        polygon = self._get_field_of_view(self.__pointing, pa)
        n_l = len(self.__grid)
        n_b = len(self.__grid[0])
        target = np.array(
            [self.__pointing.icrs.ra.rad, self.__pointing.icrs.dec.rad])
        for ll in range(n_l):
            for b in range(n_b):
                if self.included_p(polygon, target):
                    self.__grid[ll][b].append([t, num_exposure])

    @staticmethod
    def included_p(polygon: ndarray, target: ndarray):
        target = np.append(target, 0)
        z = np.zeros((len(polygon), 1))
        polygon = np.append(polygon, z, axis=1)
        win = 0
        for i in range(len(polygon)):
            j = i + 1
            if j > len(polygon) - 1:
                j = 0
            a0 = polygon[i] - target
            a1 = polygon[j] - target
            outer = np.cross(a0, a1) / (
                    np.linalg.norm(a0, ord=2) * np.linalg.norm(a1, ord=2))
            win = win + math.asin(outer[2])
        if 0.1 > win > -0.1:
            return False
        else:
            return True

    def _get_field_of_view(self, pointing, pa):
        p: Parameters = Parameters.get_instance()
        detector_x = p.detector_format_x * (
            p.num_detector_x - 1) * p.pixel_size + p.detector_separation_x
        detector_y = p.detector_format_y * (
            p.num_detector_y - 1) * p.pixel_size + p.detector_separation_y
        fov_x = detector_x / p.effective_focal_length
        fov_y = detector_y / p.effective_focal_length
        ne = np.array([fov_x / 2, fov_y / 2])
        se = np.array([fov_x / 2, -fov_y / 2])
        sw = np.array([-fov_x / 2, -fov_y / 2])
        nw = np.array([-fov_x / 2, fov_y / 2])
        rot = np.array([[math.cos(pa), math.sin(pa)], [-math.sin(pa), math.cos(pa)]])
        pa = np.array([pointing.icrs.ra.rad, pointing.icrs.dec.rad])
        ne = np.dot(rot, ne) + pa
        se = np.dot(rot, se) + pa
        sw = np.dot(rot, sw) + pa
        nw = np.dot(rot, nw) + pa
        return np.array([ne, se, sw, nw])


if __name__ == '__main__':
    p = PointingPlan()
    pointing = SkyCoord(ra=1.0 * u.deg, dec=0.0 * u.deg)
    polygon = p._get_field_of_view(pointing, math.pi / 4)
    print(polygon)
    print(type(polygon))
